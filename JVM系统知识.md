# 一、Java内存区域与内存溢出异常

## 1.运行时数据区域

### I.基本概念

JVM运行时区域可分为五个部分——**堆区、虚拟机栈、本地方法栈、方法区、程序计数器。**

- 堆区、方法区是**线程公有**的
- 虚拟机栈、本地方法栈、程序计数器是**线程私有**的

在JDK1.8之前和之后，Java内存区域有所不同，**在JDK1.8之前，方法区是在堆中由永久代实现的，在JDK1.8以后，方法区由元空间实现，元空间操作的是本地内存。**

**JDK1.8之前：**

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.8 之前）" style="zoom: 80%;" />

**JDK1.8之后：**

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）" style="zoom:80%;" />

### II.程序计数器

程序计数器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。字节码的指示工作中的指令寻址就是由程序计数器来实现的。

<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5kmznm1sj31m50u0wph.jpg" alt="jvm-pc-counter" style="zoom:50%;" />

### III.虚拟机栈

每个方法被执行的时候，JVM都会创建一个栈帧用于存储以下信息：

- **局部变量表（Local Variables）**
- **操作数栈（Operand Stack）**
- **动态链接（Dynamic Linking）：指向运行时常量池的方法引用**
- **方法返回地址（Return Address）：方法正常退出或异常退出的地址**
- **一些附加信息**

#### :ant: **局部变量表详解：**

- **局部变量表主要用于存储方法参数和定义在方法体内的局部变量**，包括编译器可知的各种 Java 虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 **returnAddress** 类型（指向了一条字节码指令的地址，已被异常表取代）

- **局部变量表中的变量只在当前方法调用中有效**。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。

- **局部变量表所需要的容量大小是编译期确定下来的**，并保存在**方法的Code属性**的 `maximum local variables` 数据项中。在方法运行期间是不会改变局部变量表的大小的

- **局部变量表最基本的存储单元是 Slot（变量槽）**，在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot

  - byte、short、char 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true

  - long 和 double 则占据两个 Slot

#### :alarm_clock: **操作数栈详解**：

- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**

- 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，**此时这个方法的操作数栈是空的**

- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性的 `max_stack` 数据项中

- 栈中的任何一个元素都可以是任意的 Java 数据类型

  - 32bit 的类型占用一个栈单位深度

  - 64bit 的类型占用两个栈单位深度

- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新 PC 寄存器中下一条需要执行的字节码指令

- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证

- **Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

####  :eagle: **动态链接（指向运行时常量池的方法引用)：**

- **每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。
- 编译期生成的各种**字面量和符号引用在类加载时放到运行时常量池中**。

- 在 Java 源文件被编译为**class字节码文件中**时，所有的**变量和方法引用**都作为**符号引用**（Symbolic Reference）保存在 **Class 文件的常量池**中。比如：描述一个方法调用了另外的其他方法时，就是**通过常量池中指向方法的符号引用来表示**的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

<img src="https://tva1.sinaimg.cn/large/0082zybply1gca4k4gndgj31d20o2td0.jpg" alt="jvm-dynamic-linking" style="zoom: 50%;" />

##### JVM 是如何执行方法调用的?

方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法）。Class 文件的编译过程中**不包括传统编译器中的链接步骤**，一切方法调用在 **Class文件**里面存储的都是**符号引用**，而不是方法在实际运行时内存布局中的入口地址（**直接引用**）。也就是需要在类**加载阶段**，甚至到**运行期才能确定目标方法的直接引用**。

在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关

- **静态链接**：当一个字节码文件被装载进 JVM 内部时，如果被调用的**目标方法在编译期可知**，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
- **动态链接**：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次**。

- 早期绑定：**早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时**，因此也就可以使用静态链接的方式在类加载时将符号引用转换为直接引用。
- 晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在**程序运行期**根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。

##### 虚方法和非虚方法

- 如果方法在编译期就**确定了具体的调用版本**，这个版本在**运行时是不可变的**。这样的方法称为**非虚方法**，比如静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法，因为这些方法**都不可以重写或未被重写**。
- 虚方法就是可以被子类重写的方法，如果子类重写了虚方法，那么**运行时将使用重写后的逻辑**，如果没有重写，则使用父类中虚方法的逻辑。

##### 虚方法表

在面向对象编程中，会频繁的使用到**动态分派**，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，JVM 采用在**类的方法区建立一个虚方法表**（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。

**每个类中都有一个虚方法表，表中存放着各个方法的实际入口。**

虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。

#### :virgo: 方法返回地址

用来存放调用该方法的 PC 寄存器的值。

一个方法的结束，有两种方式

- 正常执行完成
- 出现未处理的异常，非正常退出

#### :cake: 附加信息

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，**对程序调试提供支持的信息**，但这些信息取决于具体的虚拟机实现

### IV.本地方法栈

- 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
- 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
- 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。
- 本地方法栈也是线程私有的

### V.堆内存

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老年代(Old Generation)
3. 永久代(Permanent Generation)

**两个 Survivor 区 S0 和 S1 都属于新生代**

<img src="https://javaguide.cn/assets/hotspot-heap-structure.41533631.png" alt="hotspot-heap-structure" style="zoom:67%;" />

![JDK7](https://tva1.sinaimg.cn/large/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg)

**JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存** 

Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 `-Xmx` 和 `-Xms` 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 `OutOfMemoryError` 异常。



#### :calendar:新生代：

新生代是所有新对象创建的地方。当填充新生代时，执行垃圾收集。这种垃圾收集称为 **Minor GC**。

年轻一代被分为三个部分——伊甸园（**Eden Memory**）和两个幸存区（**Survivor Memory**，被称为from/to或s0/s1），默认比例是`8:1:1`

- 大多数对象刚被创建时都是进入新生代
- 当发生MinorGC时，新生代中存活下来的对象会进入Survivor区，并将已存在一个Survivor区的对象移到另一个Survivor区，所以Survivor区总有一个是空闲的
- 多次GC后，若该对象都逃过了GC，那么可以晋升至老年代。



#### :camel: 老年代(Old Generation)

旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。

**大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象）。这样做的目的是**避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝**



#### :paintbrush: 设置堆内存大小和 OOM

- `-Xms` 用来表示堆的**起始内存**，等价于 `-XX:InitialHeapSize`
- `-Xmx` 用来表示堆的**最大内存**，等价于 `-XX:MaxHeapSize`

如果堆的内存大小超过 `-Xmx` 设定的最大内存， 就会抛出 `OutOfMemoryError` 异常。

我们通常会将 `-Xmx` 和 `-Xms` 两个参数**配置为相同的值**，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能

- 默认情况下，初始堆内存大小为：电脑内存大小/64
- 默认情况下，最大堆内存大小为：电脑内存大小/4



#### :nail_care: 查看 JVM 堆内存分配

1. 在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小

2. 默认情况下新生代和老年代的比例是 1:2，可以通过 `–XX:NewRatio` 来配置

   - 新生代中的 **Eden**:**From Survivor**:**To Survivor** 的比例是 **8:1:1**，可以通过 `-XX:SurvivorRatio` 来配置

3. 若在 JDK 7 中开启了 `-XX:+UseAdaptiveSizePolicy`，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄

   此时 `–XX:NewRatio` 和 `-XX:SurvivorRatio`  将会失效，而 JDK 8 是默认开启`-XX:+UseAdaptiveSizePolicy`

   在 JDK 8中，**不要随意关闭**`-XX:+UseAdaptiveSizePolicy`，除非对堆内存的划分有明确的规划

#### :icecream: 对象在堆中的生命周期

当创建一个对象时，对象会被优先分配到**新生代的 Eden 区**

- 此时 JVM 会给对象定义一个**对象年轻计数器**（`-XX:MaxTenuringThreshold`）

当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）

- JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1
- 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1

如果分配的对象超过了`-XX:PetenureSizeThreshold`，对象会**直接被分配到老年代**

### VI.方法区

**方法区（method area）只是 JVM 规范中定义的一个概念**，用于存储**类信息、运行时常量池、静态变量、JIT编译后的代码等数据**，并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）是 Hotspot虚拟机特有的概念， Java8 的时候又被元空间**取代了，永久代和元空间都可以理解为**方法区的落地实现**。

所以对于方法区，Java8 之后的变化：

- 移除了永久代（PermGen），替换为元空间（Metaspace）；
- 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
- 永久代中的**字符串常量池和静态变量**转移到了 **Java堆中**；
- 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）
- <img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221106095535525.png" alt="image-20221106095535525" style="zoom:50%;" />
- <img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221106095549234.png" alt="image-20221106095549234" style="zoom:50%;" />

#### :umbrella: 设置方法区内存的大小

**JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。**

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError
```

**JDK1.8之后，可用以下参数来调整元空间的大小**

- 元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 指定，替代上述原有的两个参数
- 默认值依赖于平台。Windows 下，`-XX:MetaspaceSize` 是 21M，`-XX:MaxMetaspacaSize` 的值是 -1，即没有限制
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据发生溢出，虚拟机一样会抛出异常 `OutOfMemoryError:Metaspace`

## 2.常量池

### I.运行时常量池

- Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种**字面量**（Literal）和**符号引用**（Symbolic Reference）的 **常量池表(Constant Pool Table)** ,这部分内容**在类加载后存放到方法区的运行时常量池中**。

- 运行时常量池**是方法区的一部分**，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

- 运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时**不再是常量池中的符号地址了**，这里换为真实地址

- 运行时常量池，相对于 Class 文件常量池的另一个重要特征是：**动态性**，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 `intern()` 方法就是这样的

### II.字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

**`StringTable` 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。**

**JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。**

由于永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

## 3.直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，垃圾回收机制无法管理直接内存，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 4.HotSpot虚拟机对象详解

### I.对象的创建过程

1. **检查阶段：**当JVM遇到一条字节码new指令时，首先将去检查这个指令的参数**是否能在常量池中定位到这个类的符号引用**，并且检查这个符号引用代表的类是否已被**加载过、解析和初始化过**。如果没有，那必须先执行相应的类加载过程。

2. **内存分配阶段：**对象所需的内存大小在类加载完成后便可确认，为对象分配内存实际上就是把确定大小的内存块在堆中划分出来给对象，内存分配的方式有两种：

   - 指针碰撞 ：
     - 适用场合 ：堆内存规整（即没有内存碎片）的情况下。
     - 原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，**中间有一个分界指针**，只需要向**着没用过的内存方向**将该指针移动对象内存大小位置即可。
     - 使用该分配方式的 GC 收集器：Serial, ParNew

   - 空闲列表 ：
     - 适用场合 ： 堆内存不规整的情况下。
     - 原理 ：虚拟机会维护一个列表，该列表中会**记录哪些内存块是可用的**，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
     - 使用该分配方式的 GC 收集器：CMS

3. **解决并发安全问题：**内存分配的过程要考虑并发安全问题，比如可能正在给对象A分配内存，指针还未来得及修改，另一个线程又去给对象B分配内存，又同时使用了原来的指针。JVM采用两种方式来避免并发修改问题：

   - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
   - **TLAB（本地线程分配缓冲）：** 哪个线程要分配内存，就在哪个线程的本地缓冲区分配，只有本地缓冲区分配完了，再采用上述的 CAS 进行内存分配。可以通过`-XX+/-UseTLAB`参数来设定是否启用TLAB。

4. **初始化零值：**内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了**对象的实例字段在 Java 代码中可以不赋初始值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。

5. **设置对象头：**初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

6. **真正实例化（执行<init>()方法）:**在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——**构造函数**，`<init>` 方法还没有执行，所有的字段都还为零。new指令之后会接着执行`<init>` 方法，按照程序员的意图对对象进行初始化，这样一个对象才真正被构造出来。

### II.对象内存布局

对象由三大部分组成：**对象头、实例数据、对其填充。**

- **对象头：** **运行时数据** `（Mark Word）`、**类型指针**
  - Mark Word：存储对象自身运行时数据，如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等；类型指针：指向它的类型元数据的指针，确定该对象是哪个类的实例

- **实例数据：**对象真正存储有效的信息，即代码里所定义的各种字段内容

- **对其填充：**这是非必要的一部分，有序HotSpot虚拟机要求对象的起始地址必须是8的整数倍，所以任何对象的大小都必须是8的整数倍。

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221106141623716.png" alt="image-20221106141623716" style="zoom:30%;" />

### III.对象访问的两种方式

#### 句柄访问：

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

#### 直接指针：

如果使用直接指针访问，reference 中存储的直接就是对象的地址。

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221106141949797.png" alt="image-20221106141949797" style="zoom:25%;" />

使用直接指针来访问的方式的最大好处就是速度更快，**对于HotSpot虚拟机来说，它主要就是通过第二种方式来进行对象访问。**



## 5、内存溢出实战

### I.Java 堆内存溢出

Java 堆内存（Heap Memory)主要有两种形式的错误：

1. OutOfMemoryError: Java heap space
2. OutOfMemoryError: GC overhead limit exceeded

#### OutOfMemoryError: Java heap space

在 Java 堆中只要不断的创建对象，并且 `GC-Roots` 到对象之间存在引用链，这样 `JVM` 就不会回收对象。

只要将`-Xms(最小堆)`,`-Xmx(最大堆)` 设置为一样禁止自动扩展堆内存。当使用一个 `while(true)` 循环来不断创建对象就会发生 `OutOfMemory`，还可以使用 `-XX:+HeapDumpOutofMemoryErorr` 当发生 OOM 时会自动 dump 堆栈到文件中。

#### OutOfMemoryError: GC overhead limit exceeded

GC overhead limt exceed检查是Hotspot VM 1.6定义的一个策略，**通过统计GC时间来预测是否要OOM了，提前抛出异常，防止OOM发生。**Sun 官方对此的定义是：“并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。“

### II.MetaSpace (元数据) 内存溢出

可以使用 `-XX:MaxMetaspaceSize=10M` 来限制最大元数据。这样当**不停的创建类时将会占满该区域**并出现 `OOM`。

### III.虚拟机栈和本地方法栈溢出

如果线程请求的栈的深度大于JVM所允许的最大深度，将抛出`StackOverFlow`异常。

如果虚拟机的栈内存允许动态扩展，当扩展容量无法申请到足够的内存时，将抛出`OutOfMemoryError`异常。

如果大量创建线程，栈的大小是固定的，每个线程所得到的栈越大，所能创建的线程就越小，当线程创建过多，就会抛出`OutOfMemoryError：unble to create native thread`。由于**Java中的线程是映射到操作系统上**的，大量创建线程会给操作系统带来很大压力，可能导致操作系统假死。

**可通过`-Xss`参数来调节栈的大小**

### IV.本地内存溢出

通过Unsafe.allocateMemory()方法频繁申请内存分配，当本地内存不足时，就会发生OOM。可通过`-XX:MaxDirectMemorySize`来指定本地内存大小，如果不指定，则大小默认和堆一样。

注意，在NIO中用DirectByteBuffer类分配内存也会抛出异常，**但抛出异常时并未真正向操作系统申请分配内存**，而是提前通过计算得知内存无法分配而主动抛出的异常。真正申请内存分配的方法是`Unsafe.allocateMemory()`;

# 二、垃圾回收与内存分配详解

## 1.如何判断对象已死？

判断对象已死有两种算法：**引用计数法、可达性分析算法**，但前者会受到循环引用问题的干扰，所以目前**主流的程序语言都使用可达性分析算法来判定对象是否存活。**

### I.引用计数法：

给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

```java
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();//对象A引用 + 1
        ReferenceCountingGC objectB = new ReferenceCountingGC();//对象B引用 + 1
        objectA.instance = objectB;//对象B的引用+1
        objectB.instance = objectA;//对象A的引用+1
        //目前对象实例A和B的引用计数都为2
        objectA = null;//对象A的计数-1
        objectB = null;//对象B的计数-1
        //目前对象实例A和B的引用计数还是1，因为对象A的instance这个属性引用了对象B,对象B的instance属性引用了对象A
        System.gc(); //不会发生回收
    }
}
```

### II.可达性分析算法：

通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

<img src="https://pdai.tech/_images/pics/0635cbe8.png" alt="image" style="zoom:80%;" />

在 Java 中 GC Roots 一般包含以下内容:

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象
- 被同步锁(synchronized关键字)持有的对象
- 字符串常量池中的引用持有的对象

## 2.引用类型

### I. 强引用

**对象关联仍在，永不回收**

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();//obj是Object对象实例的强引用
```

### II. 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收，**即将发生OOM就会被回收**。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
    
```

### III. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前，**只要gc就被回收，不管内存够不够**。

使用 WeakReference 类来实现弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

### IV. 虚引用

又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。

为一个对象设置虚引用关联的唯一目的**就是能在这个对象被回收时收到一个系统通知**。

使用 PhantomReference 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);//pf是Object的虚引用
obj = null;
```

## 3.finalize()方法

finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。

finalize(）方法是对象逃脱死亡命运的最后一次机会，该方法是由虚拟机调用的，我们可以重写该方法，当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能**通过在该方法让对象与引用链上的任意一个对象建立关系**，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法，所以**自救的机会只有一次**。

 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

## 4.方法区的回收

方法区主要收集两部分内容：

- 废弃的常量
- 不再使用的类型(废弃的class)

类的卸载条件很多，需要满足以下**三个条件**，并且满足了也不一定会被卸载:

1. 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

## 5、垃圾收集算法

### 分代收集理论

**1）弱分代假说：**绝大多数对象都是朝生夕灭的

**2）强分代假说：**熬过越多次垃圾收集的对象就越难以死亡

基于以上两个假说奠定了垃圾收集器的回收原则：收集器应该给J**ava堆划分不同的区域**，然后根据对象的年龄来将它们分配到不同的区域，按照区域进行收集。有了区域的划分，也才有了**Minor GC，Full GC，Major GC**这样的回收类型。

**3）跨代引用假说：**处于老年代的对象可能引用了处于新生代的引用，但跨代引用是占极少数的

基于第3条假说，我们不能因为存在跨代引用就扫描整个老年代，只需在**新生代建立一个全局数据结构——记忆集**，它将老年代划分为若干小块并标识出哪个块存在跨代引用。此后发生Minor GC时，只有那些存在跨代引用的小块中的老年代对象才会被加入到GC Roots中进行扫描。

:pager:**GC的种类：**

- 部分收集（Partial GC）：

  - 新生代收集（Minor GC/Young GC）:只是新生代的垃圾收集

  - 老年代收集（Major GC/Old GC）:目标只是老年代的收集。注意：只有CMS收集器才会单独对老年代进行回收

  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代。目前只有G1收集器会有这种行为。

- 整堆收集（Full GC）：收集**整个Java堆和方法区**的垃圾收集。

### I.标记——清除算法

<img src="https://pdai.tech/_images/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="image" style="zoom:80%;" />

缺陷:

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### II. 标记——复制算法

<img src="https://pdai.tech/_images/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="image" style="zoom:80%;" />

**:x: 半区复制：**

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是**空间利用率较低**，只使用了内存的一半，而且如果大多数对象都未死亡，**复制开销过大**，所以**老年代的收集不适用此算法**。

:yellow_heart: **优化半区复制的策略：**

现在的商业JVM大多都采用此收集算法来**回收新生代**但是并不是将新生代划分为大小相等的两块，而是分为一块**较大的 Eden 空间和两块较小的 Survivor 空间**，每次**使用 Eden 空间和其中一块 Survivor**。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，**最后清理 Eden 和使用过的那一块 Survivor**。

**HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1**，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代分配担保机制直接进入老年代，也就是借用老年代的空间存储放不下的对象。

### III.标记——整理算法

![image](https://pdai.tech/_images/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg)

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。如果移动存活对象，尤其像老年代这样的区域会有很多存活对象以及大对象，移动并更新是一种很重的操作，这种操作要暂停用户线程才能进行，这种行为被表述为”**Stop The World**“。

为了避免这种过重的操作，做法是让虚拟机**平时都采用标记——清除算法**，暂时容忍内存碎片的存在，直到**内存碎片化程度很大**影响对象分配时，**再采用标记——整理算法**收集一次。基于标记——清除算法的**CMS收集器**在面临空间碎片化问题的时候就会采用这种办法。

## 6.HotSpot算法细节实现

### I.根节点枚举

至今为止，为了**避免根节点枚举时根节点集合对象引用关系的仍在变化带来的影响**，所有垃圾收集器在根节点枚举的时候都要**暂停用户线程。**

当用户线程暂停以后，并不需要完全遍历上下文和全局引用的位置（**从GC Root开始查找**），JVM有办法直接得到那些地方存在对象的引用。在HotSpot虚拟机中，有一组**OopMap`（Ordinary Object Pointer Map）`的数据结构**，来达到这个目的。

可以把oopMap**简单理解成是调试信息**。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。**oopMap就是一个附加的信息，告诉你栈上那个位置本来是个什么东西。**

### II.安全点（safepoint）

如果为每一条指令都生成OopMap,那将需要大量的存储空间，所以HotSpot并未为每条指令都生成OopMap，而是在特定的位置记录下这些信息，这些特定位置被称为**安全点，**有了安全点的设定，用户程序执行时并不能在指令流的任意位置都暂停下来开始垃圾收集，而是要**到安全点后才能够暂停。**

这些特定的位置主要在： 
1、循环的末尾 
2、方法临返回前 / 调用方法的call指令后 
3、可能抛异常的位置

### III.安全区域

有了安全点还不行，由于用户程序有时会处与阻塞态，这时候线程无法响应虚拟机的中断请求，这也就意味着用户程序运行到安全点去响应中断请求，所以引入了**安全区域（safe region）。**

:a: 安全区域是指在**某一段代码片段之中，引用关系不会发生变化**，因此，在这个区域中任意位置开始垃圾收集都是安全的

当用户线程**运行安全区域内的代码**，用户线程会将自己**标识为进入安全区域**，如果此时JVM发起根节点枚举，就**不必扫描安全区域内的线程**了。当线程将要离开安全区域时，它会**检查JVM是否已经完成了根节点枚举**，如果完成了，它将继续运行，否则用户线程继续等待直到收到可以离开安全区域的信号为止。

### IV.记忆集与卡表

为了解决存在跨代引用时对整个老年代对象扫描的问题，引入了记忆集这一全局数据结构，而**卡表（`card table`）正是记忆集这种数据结构最常用的实现方式。**

在HotSpot虚拟机中，卡表是一个**字节数组，**以下是卡表标记逻辑：

```java
CARD_TABLE[this address >> 9] = 1;
```

字节数组的每一个元素对应着一块内存区域，这块内存区域被称为**卡页**,比如以上这行代码，卡页的大小一般为2的N次幂，比如以上这行代码就表示了卡页大小为2^9 = 512，所以每个卡页占512bytes。

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221107160600501.png" alt="image-20221107160600501" style="zoom:23%;" />

**一个卡页中不止一个对象，只要卡页中存在跨代指针，那么卡表的数组元素就为1，称为这个元素变脏**，垃圾收集时，只用筛选出变脏的元素对应卡页进行扫描即可。

### V.写屏障

为了解决卡表维护问题**，在对象引用被修改或复制后会通过写屏障来更新卡表。** **写屏障可以看作在虚拟机层面对”引用字段类型赋值“的AOP切面**，在对象赋值的时候会形成产生一个**环绕通知**，所以赋值前后都在写屏障的覆盖范围。

### VI.并发的可达分析

枚举根节点时会暂停用户线程，由于有OopMap等优化手段的加持下，暂停时间是极为短暂的。但枚举完根节点后还要继续往下遍历对象图，如果这个过程还暂停用户线程，那么停顿时间会和Java堆的容量成正相关，暂停时间会过长。要解决这一问题，引入**三色标记法**来遍历对象图，三种颜色的具体含义如下：

- **白色：**还未被垃圾收集器访问过
- **黑色**：已被垃圾收集器访问过且该对象所持有别的对象的引用也都被访问过
- **灰色**：已被垃圾收集器访问过但该对象所持有别的对象的引用还至少有一个未被访问

**存在问题：**

- **多标：**已经被标记为黑色的对象在并发标记期间与根节点链上的对象引用关系断开了，种情况可以容忍，最多是产生浮动垃圾。
- **漏标：**经标记后不可达的对象（白色对象，已经判定为死亡）与某黑色对象建立起了引用关系，会导致该不应该死亡的对象被漏标以致于被回收。这种情况就很糟糕，可能导致致命错误。
  - **漏标必须要同时满足以下两个条件：**
    - 赋值器插入了一条或者多条从**黑色对象到白色对象的新引用**；
    - 赋值器**删除了全部从灰色对象到该白色对象**的直接或间接引用。

**为解决以上问题，产生了两种解决方案：**

- **增量更新：**黑色对象一但指向了新的白色对象，那么该黑色对象就变为灰色，本次标记结束之后再扫描一次。
- **原始快照：**当灰色对象要删除指向白色对象的引用关系时，就将这个**要删除的引用记录下来**，并发扫描结束后，再将这些记录重新扫描一次（如下图所示，G会被标记为灰色），这些对象就不会在本次垃圾收集中被回收，所以有可能产生浮动垃圾。

<img src="https://img-blog.csdnimg.cn/img_convert/521896120012814b4db01ae563e3b1a3.png" alt="img" style="zoom: 67%;" />

### VII.三色标记法与现代垃圾回收器

现代追踪式（可达性分析）的垃圾回收器**几乎都借鉴了三色标记**的算法思想，尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。

对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：

- **CMS：写屏障 + 增量更新**
- **G1：写屏障 + SATB（原始快照）**
- **ZGC：读屏障**

## 7.经典垃圾收集器

![image](https://pdai.tech/_images/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg)

​									**（以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用）**

### I. Serial 收集器

<img src="https://pdai.tech/_images/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="image" style="zoom:80%;" />

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。它是 **Client 模式下的默认新生代收集器，收集时会暂停所有用户线程**

### II. ParNew 收集器

<img src="https://pdai.tech/_images/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="image" style="zoom:80%;" />

它是 **Serial 收集器的多线程版本**。

是 **Server 模式下的虚拟机首选新生代收集器，收集时会暂停所有用户线程**，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。

### III. Parallel Scavenge 收集器

![Parallel Scavenge 收集器 ](https://javaguide.cn/assets/22018368.df835851.png)

与 ParNew 一样是**多线程新生代收集器**。

其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“**吞吐量优先”收集器**。这里的**吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。**

 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

### IV. Serial Old 收集器

![image](https://pdai.tech/_images/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg)

​																		`serial/serial old 收集器运行示意图`

是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:

- 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### V. Parallel Old 收集器

![image](https://pdai.tech/_images/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg)

是 **Parallel Scavenge 收集器的老年代版本**。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### VI.CMS收集器

![image](https://pdai.tech/_images/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg)

CMS(Concurrent Mark Sweep)，Mark Sweep 指的是**标记 - 清除算法**。

CMS是一种以获取**最短回收停顿时间**为目标的收集器，非常适合给用户带来良好的交互体验。

回收的整个过程分为以下四个流程:

- **初始标记:** 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，**需要停顿**。
- **并发标记:** 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，**不需要停顿**。
- **重新标记:** 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要停顿**。
- **并发清除:**  **不需要停顿**。

在整个过程中耗时最长的**并发标记和并发清除过程**中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

CMS在JDK1.5版本下，当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果实际应用中老年代增长速度不是过快，可以适当调高参数`-XX:CMSInitiatingOccu-pancyFraction`来提高其触发百分比，降低回收频率，以获得较高吞吐量。到JDK1.6后，其启动阈值默认提高至92%，但这存在一种风险：如果CMS运行期间预留的内存无法分配到来的对象，就会导致并发失败，这时其后备预案Serial Old将会被启用，这样用户线程就会被冻结，造成性能下降。所以参数调整不能过高。

具有以下缺点:

- **吞吐量低:** 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- **无法处理浮动垃圾**，可能出现 **并发失败**`Concurrent Mode Failure`。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- CMS是一款基于标记 - 清除算法的垃圾收集器，会**导致的空间碎片**，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### VII.G1收集器

G1 (Garbage-First) 是一款**面向服务器的垃圾收集器**,主要针对配备多颗处理器及大容量内存的机器. 以极高概率**满足 GC 停顿时间要求**的同时,还**具备高吞吐量性能特征。**

G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

<img src="https://pdai.tech/_images/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="image" style="zoom:80%;" />

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收，**Region是回收的最小单元，每个Region任何时候都可以充当任何角色（动态的），那些超过整个Region的超大对象将会被存放在N个连续的`Humongous(巨大的) Region`中，G1的大多数行为都把`Humongous Region`当作老年代来看待。**这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并**维护一个优先列表**，每次**根据允许的收集时间，优先回收价值最大的 Region**。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:

- **初始标记**：需要暂停用户线程，但耗时很短，仅仅是标记以下GC Roots所能关联到的对象即可。
- **并发标记：** **不需暂停用户线程**，递归扫描堆中对象图。当对象图扫描完后，重新处理原始快照（SATB）记录下的并发引用修改的对象
- **最终标记:** 对用户线程做一个**短暂的停顿**，处理并发阶段结束后遗留下来最后少量的原始快照(STAB)的记录。
- **筛选回收:** 首先对各个 Region 中的**回收价值和成本进行排序**，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且**停顿用户线程，多条收集线程并行完成**将大幅度提高收集效率。

<img src="https://pdai.tech/_images/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="image" style="zoom:80%;" />

**特点与优势：**

- 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

- 可预测的停顿: 可以让用户指定期望的停顿时间是G1收集器中很强大的一个功能，使用者能明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。但是停顿时间必须设置合理，如果过段，可能筛选出来的对象只占堆内存的一小部分，随着时间推移，最终造成内存溢出。

**缺点：**

- G1的**记忆集实现起来复杂**，导致G1的记忆集可能占整个堆容量的20%甚至更多内存；
- 为了实现原始快照算法，除了需要**写后屏障来维护卡表**以外，还需要**写前屏障**来跟踪并发时指针的变化，相比于增量更新算法，原始快照搜索能够减少并发标记和重新标记时的消耗，避免了CMS在最终标记阶段停顿时间过长的缺点，但用户程序会产生由**跟踪引用变化带来的额外负担。**

## 8.内存分配与回收策略

### I.对象优先在Eden区分配

大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。可以通过-XX:PrintGCDetails参数来打印收集器日志参数。

### II.大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

### III.长期存活的对象将进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（**默认为15**）则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。

### IV.动态对象年龄判断

虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold(最大年龄阈值) 才能晋升老年代，如果在 Survivor 中**低于或等于某年龄**（假设为8）的所有**对象大小总和大于Survivor空间的一半**，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到中MaxTenuringThreshold要求的年龄。

### V.空间分配担保

在发生MinorGC之前，先会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立，则该MinorGC是安全的。

如果不成立的话虚拟机会查看 `HandlePromotionFailure `设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间**是否大于历次晋升到老年代对象的平均大小**，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure **设置不允许冒险**，那么就要进行一次 **Full GC**。

## 9.为什么G1用SATB？CMS用增量更新？

增量更新：黑色对象新增一条指向白色对象的引用，那么要进行深入扫描白色对象及它的引用对象。

原始快照：灰色对象删除了一条指向白色对象的引用，实际上就产生了浮动垃圾，好处是不需要像 CMS 那样 remark，再走一遍 root trace 这种相当耗时的流程。

我的理解：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而**CMS对增量引用的根对象会做深度扫描**，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。

# 三、类文件结构详解

## 1.Class类文件概念

计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，就是java字节码，class类文件里的内容就是java字节码。

class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中,中间没有间隔，这使得**Class文件中存储的内容几乎全部都是程序运行时的必要数据**。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。

Class文件采用一种伪结构来存储数据，它有两种类型：**无符号数和表**。

- 无符号数：无符号数属于**基本数据类型**，以u1，u2，u4，u8来分别表示1个字节，2个字节，4个字节，8个字节的无符号数，无符号数可以用来描述数字，索引引用，数量值或者按照UTF-8编码构成的字符串值。
- 表：是由多个无符号数或其它表作为数据项构成的**复合数据类型**，所有表的命名都以`_info`结尾。**整个Class文件都可以看作一张表。**

**Class文件格式如下：**

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

## 2.Class类文件结构

### I.魔数与Class文件版本号：

```java
u4             magic; //Class 文件的标志
```

每个 Class 文件的**头 4 个字节称为魔数**（Magic Number）,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。

程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。

```java
u2             minor_version;//Class 的小版本号
u2             major_version;//Class 的大版本号
```

紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 字节是**次版本号**，第 7 和第 8 字节是**主版本号**。

每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 `javap -v` 命令来快速查看 Class 文件的版本号信息。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。

### II.常量池

```java
u2             constant_pool_count;//常量池的数量
cp_info        constant_pool[constant_pool_count-1];//常量池，常量池是一个数组，每个元素都是一张表
```

紧接着主次版本号之后的是常量池，常量池的数量是 `constant_pool_count-1`（**常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”**）。

常量池主要存放两大常量：**字面量(源代码中的固定值)和符号引用**。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：

- 类和接口的**全限定名**
- 字段的名称和描述符
- 方法的名称和描述符

常量池中**每一项常量都是一个表**，这 14 种表有一个共同的特点：**开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．**

|               类型               | 标志（tag） |          描述          |
| :------------------------------: | :---------: | :--------------------: |
|        CONSTANT_utf8_info        |      1      |   UTF-8 编码的字符串   |
|      CONSTANT_Integer_info       |      3      |       整形字面量       |
|       CONSTANT_Float_info        |      4      |      浮点型字面量      |
|        CONSTANT_Long_info        |     ５      |      长整型字面量      |
|       CONSTANT_Double_info       |     ６      |   双精度浮点型字面量   |
|       CONSTANT_Class_info        |     ７      |   类或接口的符号引用   |
|       CONSTANT_String_info       |     ８      |    字符串类型字面量    |
|      CONSTANT_Fieldref_info      |     ９      |     字段的符号引用     |
|     CONSTANT_Methodref_info      |     10      |   类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info |     11      |  接口中方法的符号引用  |
|    CONSTANT_NameAndType_info     |     12      |  字段或方法的符号引用  |
|     CONSTANT_MothodType_info     |     16      |      标志方法类型      |
|    CONSTANT_MethodHandle_info    |     15      |      表示方法句柄      |
|   CONSTANT_InvokeDynamic_info    |     18      | 表示一个动态方法调用点 |

Class文件中的方法、字段都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法名，字段名的最大长度。

### III.访问标志(Access Flags)

在常量池结束之后，紧接着的**2个字节代表访问标志**，这个标志用于**识别一些类或者接口层次的访问信息**，包括：这个 Class 是类还是接口，是否为 `public` 或者 `abstract` 类型，如果是类的话是否声明为 `final` 等等。

类访问和属性修饰符:

![类访问和属性修饰符](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png)

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221108152340498.png" alt="image-20221108152340498" style="zoom:75%;" />

###  IV.当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合



```java
u2             this_class;//当前类
u2             super_class;//父类
u2             interfaces_count;//接口
u2             interfaces[interfaces_count];//一个类可以实现多个接口
```

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。

接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 `implements` (如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。

**通过 jclasslib 可以看到类的继承关系**：

![image-20221108152654797](C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221108152654797.png)

- this_class 指向常量池中索引为 32 的 *CONSTANT_Class_info*。
- super_class 指向常量池中索引为 2 的 *CONSTANT_Class_info*。
- 由于没有接口，所以 interfaces 的信息为空。
- 通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在类型的常量中的全限定名称字符串，即<ThreadTest\>、<java/long/Object\>等类名。

### V.字段表集合

```java
u2             fields_count;//Class 文件的字段的个数
field_info     fields[fields_count];//一个类会可以有个字段
```

字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。

**field info(字段表) 的结构:**

![字段表的结构 ](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

- **access_flags:** 字段的作用域（`public` ,`private`,`protected`修饰符），是实例变量还是类变量（`static`修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。
- **name_index:** 对常量池中CONSTANT_Utf8_info常量的引用，表示的字段的名称；
- **descriptor_index:** 对常量池中*CONSTANT_Utf8_info*常量的引用，表示字段和方法的描述符，针对不同的数据类型，会有不同规则的描述信息；
- **attributes_count:** 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；
- **attributes[attributes_count]:** 存放具体属性具体内容。

上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。

**字段的 access_flag 的取值:**

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084342859.png" alt="字段的 access_flag 的取值" style="zoom: 55%;" />

1）对于基本数据类型来说，使用一个字符来表示，比如说 I 对应的是 int，B 对应的是 byte。

2）对于引用数据类型来说，使用 `L***;` 的方式来表示，`L` 开头，`;` 结束，比如字符串类型为 `Ljava/lang/String;`。

3）对于数组来说，会用一个前置的 `[` 来表示，比如说字符串数组为 `[Ljava/lang/String;`。

![image-20221108153920751](C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221108153920751.png)

### VI.方法表集合

```java
u2             methods_count;//Class 文件的方法的数量
method_info    methods[methods_count];//一个类可以有个多个方法
```

methods_count 表示方法的数量，而 method_info 表示方法表。

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

**method_info(方法表的) 结构:**

![方法表的结构](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png)

**方法表的 access_flag 取值：**

<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/JVM/image-20201031084248965.png" alt="方法表的 access_flag 取值" style="zoom:57%;" />

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221108154228178.png" alt="image-20221108154228178" style="zoom:80%;" />

### VII.属性表集合

```java
u2             attributes_count;//此类的属性表中的属性数
attribute_info attributes[attributes_count];//属性表集合
```

**在 Class 文件，字段表，方法表中都可以携带自己的属性表集合**，`（可以将字段表，方法表当作类，属性当作类的成员变量）`以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221108155056862.png" alt="image-20221108155056862" style="zoom:67%;" />

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221108155116523.png" alt="image-20221108155116523" style="zoom:80%;" />

属性有很多，如**Code属性（用于方法表），LineNumberTable属性（用于Code属性），Signature属性（用于类、方法、字段表）**等等，因为**不同的表有不同的属性甚至不同的属性中还有它们自己不同的属性**，所以各个属性的使用位置不同。

## 3.字节码指令大全

| **常量入栈指令** |                      |                      |                                                              |
| ---------------- | -------------------- | -------------------- | ------------------------------------------------------------ |
| **指令码**       | **操作码（助记符）** | **操作数**           | **描述（栈指操作数栈）**                                     |
| 0x01             | aconst_null          |                      | null值入栈。                                                 |
| 0x02             | iconst_m1            |                      | -1(int)值入栈。                                              |
| 0x03             | iconst_0             |                      | 0(int)值入栈。                                               |
| 0x04             | iconst_1             |                      | 1(int)值入栈。                                               |
| 0x05             | iconst_2             |                      | 2(int)值入栈。                                               |
| 0x06             | iconst_3             |                      | 3(int)值入栈。                                               |
| 0x07             | iconst_4             |                      | 4(int)值入栈。                                               |
| 0x08             | iconst_5             |                      | 5(int)值入栈。                                               |
| 0x09             | lconst_0             |                      | 0(long)值入栈。                                              |
| 0x0a             | lconst_1             |                      | 1(long)值入栈。                                              |
| 0x0b             | fconst_0             |                      | 0(float)值入栈。                                             |
| 0x0c             | fconst_1             |                      | 1(float)值入栈。                                             |
| 0x0d             | fconst_2             |                      | 2(float)值入栈。                                             |
| 0x0e             | dconst_0             |                      | 0(double)值入栈。                                            |
| 0x0f             | dconst_1             |                      | 1(double)值入栈。                                            |
| 0x10             | bipush               | valuebyte            | valuebyte值带符号扩展成int值入栈。                           |
| 0x11             | sipush               | valuebyte1valuebyte2 | (valuebyte1 << 8) \| valuebyte2 值带符号扩展成int值入栈。    |
| 0x12             | ldc                  | indexbyte1           | 常量池中的常量值（int, float, string reference, object reference）入栈。 |
| 0x13             | ldc_w                | indexbyte1indexbyte2 | 常量池中常量（int, float, string reference, object reference）入栈。 |
| 0x14             | ldc2_w               | indexbyte1indexbyte2 | 常量池中常量（long, double）入栈。                           |

| 局部变量值转载到栈中指令 |                      |            |                                                              |
| ------------------------ | -------------------- | ---------- | ------------------------------------------------------------ |
| **指令码**               | **操作码（助记符）** | **操作数** | **描述（栈指操作数栈）**                                     |
| 0x19                     | (wide)aload          | indexbyte  | 从局部变量indexbyte中装载引用类型值入栈。                    |
| 0x2a                     | aload_0              |            | 从局部变量0中装载引用类型值入栈。                            |
| 0x2b                     | aload_1              |            | 从局部变量1中装载引用类型值入栈。                            |
| 0x2c                     | aload_2              |            | 从局部变量2中装载引用类型值入栈。                            |
| 0x2d                     | aload_3              |            | 从局部变量3中装载引用类型值入栈。                            |
| 0x15                     | (wide)iload          | indexbyte  | 从局部变量indexbyte中装载int类型值入栈。                     |
| 0x1a                     | iload_0              |            | 从局部变量0中装载int类型值入栈。                             |
| 0x1b                     | iload_1              |            | 从局部变量1中装载int类型值入栈。                             |
| 0x1c                     | iload_2              |            | 从局部变量2中装载int类型值入栈。                             |
| 0x1d                     | iload_3              |            | 从局部变量3中装载int类型值入栈。                             |
| 0x16                     | (wide)lload          | indexbyte  | 从局部变量indexbyte中装载long类型值入栈。                    |
| 0x1e                     | lload_0              |            | 从局部变量0中装载int类型值入栈。                             |
| 0x1f                     | lload_1              |            | 从局部变量1中装载int类型值入栈。                             |
| 0x20                     | lload_2              |            | 从局部变量2中装载int类型值入栈。                             |
| 0x21                     | lload_3              |            | 从局部变量3中装载int类型值入栈。                             |
| 0x17                     | (wide)fload          | indexbyte  | 从局部变量indexbyte中装载float类型值入栈。                   |
| 0x22                     | fload_0              |            | 从局部变量0中装载float类型值入栈。                           |
| 0x23                     | fload_1              |            | 从局部变量1中装载float类型值入栈。                           |
| 0x24                     | fload_2              |            | 从局部变量2中装载float类型值入栈。                           |
| 0x25                     | fload_3              |            | 从局部变量3中装载float类型值入栈。                           |
| 0x18                     | (wide)dload          | indexbyte  | 从局部变量indexbyte中装载double类型值入栈。                  |
| 0x26                     | dload_0              |            | 从局部变量0中装载double类型值入栈。                          |
| 0x27                     | dload_1              |            | 从局部变量1中装载double类型值入栈。                          |
| 0x28                     | dload_2              |            | 从局部变量2中装载double类型值入栈。                          |
| 0x29                     | dload_3              |            | 从局部变量3中装载double类型值入栈。                          |
| 0x32                     | aaload               |            | 从引用类型数组中装载指定项的值。                             |
| 0x2e                     | iaload               |            | 从int类型数组中装载指定项的值。                              |
| 0x2f                     | laload               |            | 从long类型数组中装载指定项的值。                             |
| 0x30                     | faload               |            | 从float类型数组中装载指定项的值。                            |
| 0x31                     | daload               |            | 从double类型数组中装载指定项的值。                           |
| 0x33                     | baload               |            | 从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |
| 0x34                     | caload               |            | 从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |
| 0x35                     | saload               |            | 从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。 |

| **对象操作指令** |                      |                      |                          |
| ---------------- | -------------------- | -------------------- | ------------------------ |
| **指令码**       | **操作码（助记符）** | **操作数**           | **描述（栈指操作数栈）** |
| 0xbb             | new                  | indexbyte1indexbyte2 | 创建新的对象实例。       |
| 0xc0             | checkcast            | indexbyte1indexbyte  | 类型强转。               |
| 0xc1             | instanceof           | indexbyte1indexbyte2 | 判断类型。               |
| 0xb4             | getfield             | indexbyte1indexbyte2 | 获取对象字段的值。       |
| 0xb5             | putfield             | indexbyte1indexbyte2 | 给对象字段赋值。         |
| 0xb2             | getstatic            | indexbyte1indexbyte2 | 获取静态字段的值。       |
| 0xb3             | putstatic            | indexbyte1indexbyte2 | 给静态字段赋值。         |

| **方法调用指令** |                      |                            |                                                              |
| ---------------- | -------------------- | -------------------------- | ------------------------------------------------------------ |
| **指令码**       | **操作码（助记符）** | **操作数**                 | **描述（栈指操作数栈）**                                     |
| 0xb7             | invokespecial        | indexbyte1indexbyte2       | 调用一些需要特殊处理的方法，包括实例初始化方法，私有方法和父类方法。 |
| 0xb6             | invokevirtual        | indexbyte1indexbyte2       | 调用对象实例方法。                                           |
| 0xb8             | invokestatic         | indexbyte1indexbyte2       | 调用静态方法。                                               |
| 0xb9             | invokeinterface      | indexbyte1indexbyte2count0 | 调用接口方法。                                               |
|                  | invokedynamic        |                            | λ表达式中接口方法的解析就通过该指令实现                      |

# 四、虚拟机类加载机制

## 1.类加载的时机

类加载是指一个Java类型（class对象）被载入内存，java中的类型被载入内存到卸载出内存共有**七个阶段**：

**加载、验证、准备、解析、初始化、使用、卸载；**

![img](https://pdai.tech/_images/jvm/java_jvm_classload_2.png)

**加载、验证、准备、初始化、卸载**这五个步骤的顺序是确定的，而**解析**阶段何时发生却**未确定**，可能**发生在初始化之后**，这是为了支持Java语言的**动态绑定特性**。

什么时候开始类加载的第一阶段**”加载“**，《JVM规范》中未强制约束，但何时发生**初始化**却是有严格规范的，有**六种情况**必须立即对类进行**初始化：**

1. 遇到`new`,`getstatic`,`putstatic`,`invokestatic`这四条字节码指令的时候，如果该类未初始化，则会触发初始化阶段。能够生成这些指令的java代码有：

   - new关键字实例化对象

   - 读取类中的静态变量（final修饰除外，因为final修饰的变量是编译时生成的常量）

   - 给类中的静态变量赋值

   - 调用一个类的静态方法

2. 使用java.lang.reflect包中的方法对类型进行反射调用

3. 当类初始化的时候，如果其父类还未初始化，则先进行父类的初始化

4. 虚拟机启动时，包含main()方法的那个类需进行初始化

5. JDK 7时新加入的java.lang.invoke.MethodHandle实例最后会解析出四种类型的方法句柄，并且这个方法句柄对应的类未被初始化，则需要先对其进行初始化。

6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

## 2.类加载具体过程

### I.加载

类加载过程的第一步，主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为**方法区的运行时数据结构（运行时常量池等）**
3. 在**堆内存**中生成一个代表该类的 `java.long.Class` 对象，作为方法区这些数据的访问入

类加载器并**不需要等到某个类被“首次主动使用”时再加载它**，JVM规范允许类加载器**在预料某个类将要被使用时就预先加载它**，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。

### II.验证

验证是连接阶段的第一步，这一阶段的目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。**验证阶段大致会完成4个阶段的检验动作:

- `文件格式验证`: 验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- `元数据验证`: 对**字节码描述的信息进行语义分析**(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Object`之外；这个类是否继承了不允许被继承的类（final修饰的类）等。
- `字节码验证`: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- `符号引用验证`: 检验符号引用中的类、字段、方法的可访问性等，确保解析动作能正确执行。

### III.准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。

- 这时候进行内存分配的**仅包括类变量(**`static`)，而**不包括实例变量**，实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 这里所设置的**初始值通常情况下是数据类型默认的零值**(如`0`、`0L`、`null`、`false`等)，而不是被在Java代码中被显式地赋予的值。
- 假设一个类变量的定义为: `public static int value = 3`；那么变量value在准备阶段过后的初始值为`0`，而不是`3`，因为这时候尚未开始执行任何Java方法，而把value赋值为3的`put static`指令是在程序编译后，存放于类构造器`<clinit>()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

### IV.解析

解析阶段是虚拟机将常量池内的**符号引用替换为直接引用**的过程。解析动作主要针对类或**接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符** 7 类符号引用进行。

**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### V.初始化

初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始**真正执行类中定义的 Java 程序代码**(字节码)，该阶段为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:

- 声明类变量是指定初始值
- 使用静态代码块为类变量指定初始值

**JVM初始化步骤**

- 假如这个类还没有被加载和连接，则程序先加载并连接该类
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 假如类中有初始化语句，则系统依次执行这些初始化语句

**JVM必须保证一个类的<clinit\>()方法在多线程环境中被正确的加锁同步**，如果多个线程同时去初始化一个类，那么只有一个类会初始化成功，其它类都将阻塞等待。

## 3.类与类加载器

### I.类加载器

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

<img src="https://pdai.tech/_images/jvm/java_jvm_classload_3.png" alt="img" style="zoom:80%;" />

这里父类加载器并**不是通过继承关系来实现的，而是采用组合实现的。**

对于任意一个类，必须有**类本身和加载它的类加载器共同来确定其在JVM中的唯一性**，也就是说，不同类加载器加载同一个名为Person的类，其在JVM中并不是同一个类，当用instanceof关键字判断这两类实例时得到的值为false。

### II.双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader" style="zoom:67%;" />

- **启动类加载器**: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的**java.*开头的类均被Bootstrap ClassLoader加载**)。启动类加载器是无法被Java程序直接引用的。
- **扩展类加载器**: Extension ClassLoader，该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。
- **应用程序类加载器**: Application ClassLoader，该类加载器由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载**用户类路径(ClassPath)所指定的类（我们自己编写的类）**，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中**默认的类加载器**。
- **自定义类加载器：**有的时候，我们也需要自定义类加载器。比如应用是**通过网络来传输 Java 类的字节码，为保证安全性**，**这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现**。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。

#### **双亲委派是怎么实现的？**

**实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中**：

```java
protected Class<?> loadClass(String name, boolean resolve)

            throws ClassNotFoundException

        {
            synchronized (getClassLoadingLock(name)) {
                // First, check if the class has already been loaded
                Class<?> c = findLoadedClass(name);
                if (c == null) {
                    long t0 = System.nanoTime();
                    try {
                        if (parent != null) {
                            c = parent.loadClass(name, false);
                        } else {
                            c = findBootstrapClassOrNull(name);
                        }
                    } catch (ClassNotFoundException e) {
                        // ClassNotFoundException thrown if class not found
                        // from the non-null parent class loader
                    }
                    if (c == null) {
                        // If still not found, then invoke findClass in order
                        // to find the class.
                        long t1 = System.nanoTime();
                        c = findClass(name);
                        // this is the defining class loader; record the stats
                        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                        sun.misc.PerfCounter.getFindClasses().increment();
                    }
                }
                if (resolve) {
                    resolveClass(c);
                }
                return c;
            }
        }
```

#### **为什么需要双亲委派？**

这种机制有几个好处：

- 首先，**通过委派的方式，可以避免类的重复加载**，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。
- 另外，**通过双亲委派的方式，还保证了安全性**。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。

### **III.如何主动破坏双亲委派机制？**

因为双亲委派过程都是在loadClass方法中实现的，那么**想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。**

#### **loadClass（）、findClass（）、defineClass（）区别**

ClassLoader中和类加载有关的方法有很多，前面提到了loadClass，除此之外，还有findClass和defineClass等，那么这几个方法有什么区别呢？

- *loadClass()* 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
- *findClass()* 根据名称或位置加载.class字节码
- *definclass()* 把字节码转化为Class

这里面需要展开讲一下loadClass和findClass，我们前面说过，当我们想要自定义一个类加载器的时候，并且像破坏双亲委派原则时，我们会重写loadClass方法。

那么，如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？

这时候，就可以继承ClassLoader，并且重写findClass方法。findClass()方法是JDK1.2之后的ClassLoader新添加的一个方法。

```java

    protected Class<?> findClass(String name) throws ClassNotFoundException {

        throw new ClassNotFoundException(name);

    }
```

这个方法只抛出了一个异常，没有默认实现。

**JDK1.2之后已不再提倡用户直接覆盖loadClass()方法**，而是建议把自己的类加载逻辑实现到findClass()方法中。

因为在**loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载**。

**所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass中实现你自己的加载逻辑即可。**

#### **双亲委派被破坏的例子**

双亲委派机制的破坏不是什么稀奇的事情，很多框架、容器等都会破坏这种机制来实现某些功能。

- **第一种被破坏的情况是在双亲委派出现之前。**

由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。

- **第二种，是JNDI、JDBC等需要加载SPI接口实现类的情况。**

- **第三种是为了实现热插拔热部署工具。**为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。

- **第四种是tomcat等web容器的出现。**

- **第五种是OSGI、Jigsaw等模块化技术的应用。**

# 五、虚拟机字节码执行引擎

## 1.运行时栈结构

Java虚拟机以方法法作为最基本的执行单元，“栈帧”(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。

每一个栈帧都包括了**局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息**。操作数栈的深度在编译时就被分析计算出来并被写到方法的Code属性中去。

<img src="C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221109152646249.png" alt="image-20221109152646249" style="zoom:18%;" />

## 2.方法调用

方法调用阶段唯一的任务就是确定被调用方法的版本（调用哪一个方法），暂时未涉及到具体运行过程。

### I.解析调用：

方法调用的目标方法在class文件里都是一个常量池的符号引用，**在类加载阶段，一部分符号引用会解析为直接引用**，这种解析能够成立的前提是调用目标在被编译那一刻就确定了，即“编译器可知，运行期不可变”。符合这种要求的方法主要有**静态方法、私有方法。**它们的共同特点是**都不可能通过继承或别的方式重写出其它版本**。

JVM支持以下5条方法调用的字节码指令：

- **invokestatic：**调用静态方法
- **invokespecial：**调用实例构造器<init\>()方法、私有方法和父类中的方法
- invokevirtual：调用所有实例（虚）方法
- invokeinterface：调用接口方法，会在运行时确定一个实现该接口的对象
- invokedynamic：先在运行时动态解析出调用点限定符中所引用的方法，再执行用户实现的方法(生产者消费者接口就是这样实现的)。

invokestatic和invokespecial，都可以再解析阶段确定唯一调用版本，Java语言中符合这个条件的方法有：**静态方法、私有方法、父类方法、实例构造器方法、final修饰的方法**（尽管它使用invokevirtual）。**这五类方法再类加载时就可把符号引用转化为直接引用**。

解析调用是一个静态的过程，编译期完全确定。

### II.分派调用：

对于面向对象语言，多态是一个极为重要的特性。在Java虚拟机中的**重载、重写的实现由分派支持**，分派调用过程也揭示了一些多态的特征。分派本身就是具有动态性的，分派又分为**静态分派和动态分派**。

#### :parasol_on_ground:静态分派：

所有**依赖静态类型来决定方法的调用版本的分派动作都称为静态分派**，静态分派最典型的应用就是**方法的重载**。**静态分派发生在编译阶段。**

在以下代码中，父类“Human”称为静态类型，后面的两个类称为实际类型，两个对象（man,woman）的静态类型相同，实际类型不同，但虚拟机在重载时是通过参数的静态类型来作为判定依据的。静态类型编译是可知，所以在**编译时就决定使用哪个重载版本**，所以都选择了`sayHello(Human human)`作为调用目标。

```java
package dispatch;

/**
 * @author VictorG
 * @date 2022/11/9 16:00
 */
public class StaticDispatch {
    static abstract class Human {}
    static class Man extends Human {}
    static class Woman extends Human {}

    public void sayHello(Human human) {
        System.out.println("hello，Human");
    }
    public void sayHello(Man human) {
        System.out.println("hello，man");
    }
    public void sayHello(Woman woman) {
        System.out.println("hello，woman");
    }

    public static void main(String[] args) {
        StaticDispatch sd = new StaticDispatch();
        Human man = new Man();
        Human woman = new Woman();
        sd.sayHello(man);
        sd.sayHello(woman);
    }
}
//运行结果：
hello，Human
hello，Human
```

#### :tent:动态分派：

动态分派与**重写（Override）**有着密切关系。动态分派是在invokevirtual指令执行时开始的，步骤如下：

1. 将操作数栈顶第一个元素指向实际类型，记作C
2. 如果类型C中的常量表有名称相同的方法且符合访问权限，则返回该方法的直接引用，如果不符合访问权限则抛异常（IllegalAccessError）
3. 接着按照继承关系自下而上按照前一个步骤检查父类
4. 如果始终未找到合适方法，则抛出`java.lang.AbstractMethodError`

```java
package dispatch;

/**
 * @author VictorG
 * @date 2022/11/9 16:00
 */
public class StaticDispatch {
    static abstract class Human {
        public void sayHello() {
            System.out.println("hello，Human");
        }
    }
    static class Man extends Human {
        public void sayHello() {
            System.out.println("hello，man");
        }
    }
    static class Woman extends Human {
        public void sayHello() {
            System.out.println("hello，woman");
        }
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
    }
}
//运行结果：
hello，man
hello，woman
```

**字段不具有多态性：**哪个类的方法访问某个名字的字段时，如果在子类中声明了和父类相同的字段，虽然在**子类的内存中两个字段都会存在，但子类会遮掩掉父类的同名字段。**

#### :oil_drum:虚拟机动态分派的实现：

由于动态分派是非常频繁的动作，正真运行时不会如此频繁地去反复搜索元数据类型。Java虚拟机在方法区中为每个类建立了一个**虚方法表**`（vtable）`,使用虚方法表来代替元数据查找以提高性能。

虚方法表中存放各个方法的实际入口地址，如果某个方法在子类中没有被重写，那么子类虚方法表中的入口地址与父类方法相同，如果重写了，子类虚方法表中的地址将会被替换为子类重写方法的入口地址。

<img src="https://img-blog.csdnimg.cn/img_convert/525ee5e055164d1a72c128a29178f5a3.png" alt="img" style="zoom:80%;" />

## 3.动态类型语言

在JDK7以前，方法的符号引用都是在编译时产生的，而动态类型语言只有在运行期间才能确定方法的接收者。在JDK7之后，引入了java.lang.invoke包，这个包提供了一种新的动态确定目标方法的机制，”**方法句柄**（Method Handle）“，可类比C语言中的函数指针。这样，就可以实现将函数作为函数参数传递了。

动态类型语言底层是由**invokedynamic指令**支持的，每一处含有该指令的位置都被称为**动态调用点，**这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是JDK7之后加入的CONSTANT_InvokeDynamic_info常量，从这个常量中可以得到3项信息：**引导方法、方法类型、方法名称**。

## 4.动态代理的实现

动态代理在Java开发中十分常用，比如Spring中的对Bean的增强就是用动态代理来实现的，动态代理实际上是依赖于字节码生成技术，它的优势不在于省去编写代理类的那点工作量，而是实现了在原始类和接口都未知的情况下就确定了代理关系，使代理类和原始类脱离关系。

**静态代理的特点：**

1、目标角色固定

2、在应用程序执行前就得到目标角色

3、代理对象会增强目标对象的行为

4、有可能存在多个代理 引起"类爆炸"（缺点）

```java
public class StaticProxyTest {
    interface Human {
        void say();
    }

    static class Man implements Human {
        public void say() {
            System.out.println("Hello man");
        }
    }

    static class ManProxy implements Human {
        private Human human;

        public ManProxy(Human human) {
            this.human = human;
        }

        @Override
        public void say() {
            System.out.println("before...");
            human.say();
            System.out.println("after");
        }
    }

    public static void main(String[] args) {
        //目标对象
        Man man = new Man();
        //构造代理对象，并将代理对象传入
        ManProxy manProxy = new ManProxy(man);
        manProxy.say();
    }
}
```



**动态代理的特点：**

1. 目标对象不固定
2. 在应用程序执行时动态创建目标对象
3. 代理对象会增强目标对象的行为

```java
package com.cs.G.Exception;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author VictorG
 * @date 2022/11/10 14:07
 */
public class DynamicProxyTest {
    interface Human {
        void saveWorld();
    }

    static class Man implements Human {

        @Override
        public void saveWorld() {
            System.out.println("I'm man");
        }
    }

    static class JdkHandler implements InvocationHandler {
        Object target;

        public JdkHandler(Object target) {// 目标对象的类型不固定，运行时动态生成
            this.target = target;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("I become superman");
            //调用目标对象的目标方法
            Object res = method.invoke(target, args);
            System.out.println("I'will save the world");
            return res;
        }
        //获取代理对象
        public Object getProxy() {
            return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
        }
    }

    public static void main(String[] args) {
        Man man = new Man();
        man.saveWorld();
        System.out.println("..............");
        JdkHandler superMan = new JdkHandler(man);
        Man manProxy= (Man) superMan.getProxy();
        manProxy.saveWorld();
    }
}
```

**当执行Proxy::newProxyInstance()方法的时候，最后会调用sun.misc.ProxyGenerator::generatorProxtClass()方法来完成生成字节码，这个方法在运行时会产生一个描述代理类的字节码byte[]数组。**

```java
static byte[] generateProxyClass(final String name,
                                     Class<?>[] interfaces,
                                     int accessFlags)
    {
        ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);
        final byte[] classFile = gen.generateClassFile();
        if (saveGeneratedFiles) {
            java.security.AccessController.doPrivileged(
            new java.security.PrivilegedAction<Void>() {
                public Void run() {
                    try {
                        int i = name.lastIndexOf('.');
                        Path path;
                        if (i > 0) {
                            Path dir = Path.of(name.substring(0, i).replace('.', File.separatorChar));
                            Files.createDirectories(dir);
                            path = dir.resolve(name.substring(i+1, name.length()) + ".class");
                        } else {
                            path = Path.of(name + ".class");
                        }
                        Files.write(path, classFile);
                        return null;
                    } catch (IOException e) {
                        throw new InternalError(
                            "I/O exception saving generated file: " + e);
                    }
                }
            });
        }
        return classFile;//返回一个代理类字节码文件
    }
```

**动态代理的优势：**

- 静态代理类必须和目标类实现同一接口，并且在代理类中还要聚合目标类。在这种情况下，如果该代理类要增强多个目标类，那就要创建相应个数的代理对象，这就会引起**类爆炸**，并且代码的复用性会变得十分差劲。
- 相比于静态代理，动态代理在创建代理对象上更加的灵活，动态代理类的字节码在程序运行时，由Java反射机制动态产生。它会根据需要，通过反射机制在程序运行期，**动态的为目标对象创建代理对象**，**在JDK动态代理中，代理类只需实现InvocationHandler接口即可，并编写方法的增强逻辑即可，无需程序员手动编写它的源代码。**动态代理不仅简化了编程工作，而且提高了软件系统的可扩展性，因为反射机制可以生成任意类型的动态代理类。代理的行为可以代理**多个方法**，**即满足生产需要的同时又达到代码通用的目的，代码的复用性很好**。

**JDK动态代理类中的invoke是怎么调用的？**

在生成的动态代理类$Proxy0.class中，构造方法调用了父类Proxy.class的构造方法，给成员变量invocationHandler赋值，$Proxy0.class的static代码块中创建了被代理类的方法，调用相应方法时方法体中调用了父类中的成员变量InvocationHandler的invoke()方法。**无论调用动态代理的哪一个方法，实际上都是在执行invoke()方法中的代理逻辑，比如我调用了代理对象的hashcode()方法，代理逻辑依然会执行。**

# 六、编译与优化

## 1.Java中的语法糖

### I.泛型擦除

通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。

　　Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。也就是说，对于Java虚拟机来说，他根本不认识Map<String, String> map这样的语法。需要在**编译阶段通过类型擦除的方式进行解语法糖**。

类型擦除的主要过程如下：

-  1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。
-  2.移除所有的类型参数。

　　以下代码：

```java
Map<String, String> map = new HashMap<String, String>();  
map.put("name", "hollis");  
map.put("wechat", "Hollis");   
```

解语法糖之后会变成：

```java
Map map = new HashMap();  
map.put("name", "hollis");  
map.put("wechat", "Hollis");  
```

### II.自动装箱与自动拆箱

**自动装箱就是Java自动将原始类型值转换成对应的对象**，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。

　　因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。

　　先来看个自动装箱的代码：

```java
 public static void main(String[] args) {
    int i = 10;
    Integer n = i;
}
```

　　反编译后代码如下:

```java
public static void main(String args[]){
    int i = 10;
    Integer n = Integer.valueOf(i);
}
```

　　再来看个自动拆箱的代码：

```java
public static void main(String[] args) {
    Integer i = 10;
    int n = i;
}
```

　　反编译后代码如下：

```java
public static void main(String args[]){
    Integer i = Integer.valueOf(10);
    int n = i.intValue();
}
```

　　从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。所以，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。

### III.可变长参数

可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。

　　看下以下可变参数代码，其中print方法接收可变参数：

```java
public static void main(String[] args){
　　print("Holis", "公众号:Hollis", "博客：www.csg.com", "QQ：9534566122");
}

public static void print(String... strs){
　　for (int i = 0; i < strs.length; i++){
　　　　System.out.println(strs[i]);
　　}
}
```

　　反编译后代码：

```java
public static void main(String args[]){
　　print(new String[] {
　　　　"Holis", "公众号:Hollis", "博客：www.csg.com", "QQ：9534566122"
　　});
}

public static transient void print(String strs[]){
　　for(int i = 0; i < strs.length; i++)
　　　　System.out.println(strs[i]);

}
```

　　从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。

### **IV.内部类**

内部类又称为嵌套类，可以把**内部类理解为外部类的一个普通成员**。内部类之所以也是语法糖，是因为它**仅仅是一个编译时的概念**。outer.java里面定义了一个内部类inner，一旦编译成功，就会**生成两个完全不同的.class文件了**，分别是outer.class和outer$inner.class。

### **V.条件编译**

一般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：

```java
public class ConditionalCompilation {
　　public static void main(String[] args) {
　　　　final boolean DEBUG = true;
　　　　if(DEBUG) {
　　　　　　System.out.println("Hello, DEBUG!");
　　　　}

　　　　final boolean ONLINE = false;
　　　　if(ONLINE){
　　　　　　System.out.println("Hello, ONLINE!");
　　　　}
　　}
}
```

反编译后代码如下：

```java
public class ConditionalCompilation {
　　public static void main(String[] args) {
　　　　final boolean DEBUG = true;
　　　　if(DEBUG) {
　　　　　　System.out.println("Hello, DEBUG!");
　　　　}
　　　　final boolean ONLINE = false;
}
```

### IV. …………

**增强for循环**、**Lambda表达式**

## 2.即时编译

### I.概念：

Java程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行效率特别频繁，就会将那段代码编译为本地代码，即计算机能够直接识别的机器指令，并以各种手段尽可能地进行代码优化。这个任务是由被**称为即使编译器的后端编译器**来完成的。

### II.即使编译的对象与触发条件：

**编译对象：**

- 被多次调用的方法

- 被多次执行的循环体

**判定方法：**

- 基于采样的热点探测：虚拟机周期性检查各个线程调用栈顶，如果发现某个方法经常出现在栈顶，那么这个方法就是热点方法。该判定方法虽简单高效，但对于热点的确定不够精确，容易收到线程阻塞的影响。
- 基于计数器的热点探测：为每个方法或代码块建立计数器，统计执行次数，超过设定阈值即为热点方法。实现起来麻烦但统计结果精确。

这两种方法在商用虚拟机都有用到，对于计数器阈值可以根据该虚拟机的相关参数进行调节。