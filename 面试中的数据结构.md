# 一、AVL树

## 1. 为什么使用「平衡二叉树」

二叉树能提高查询的效率 O(logn)，但是当你插入 `{1,2,3,4,5,6}` 这种数据的时候，你的二叉树就像一个「[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)」一样，搜索效率变为 O(n)

## 2. 判断「平衡二叉树」

判断「平衡二叉树」的 2 个条件：

- **1. 是「二叉排序树」**
- **2. 任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）**

## 3.相关概念

### 3.1 平衡因子 BF

定义：左子树和右子树高度差

计算：左子树高度 - 右子树高度的值

别名：简称 BF（Balance Factor 而不是 Boy Friend）

一般来说 BF 的绝对值大于 1，,平衡树二叉树就失衡，需要「旋转」纠正

### 3.2 最小不平衡子树

距离插入节点最近的，并且 BF 的绝对值大于 1 的节点为根节点的子树。

「旋转」纠正只需要纠正「最小不平衡子树」即可

![image-20221009101349051](C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221009101349051.png)

### 4、.二种旋转方式

2 种「旋转」方式：

左旋
旧根节点为新根节点的左子树
新根节点的左子树（如果存在）为旧根节点的右子树
右旋：
旧根节点为新根节点的右子树
新根节点的右子树（如果存在）为旧根节点的左子树

4 种「旋转」纠正类型：

LL 型：插入左孩子的左子树，右旋
RR 型：插入右孩子的右子树，左旋
LR 型：插入左孩子的右子树，先左旋，再右旋
RL 型：插入右孩子的左子树，先右旋，再左旋
![image-20221009101442455](C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221009101442455.png)

**用这组数据构建AVL树帮助理解**

**{3,2,1,4,5,6,7,10,9,8}**

# 二、红黑树

## 1.概述

### 1.1 红黑树的引入

**有了二叉搜索树，为什么还需要平衡二叉树？**

- 在学习二叉搜索树、平衡二叉树时，我们不止一次提到，二叉搜索树容易退化成一条链这时，查找的时间复杂度从O(log 2N ) O(N)。
- 引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log2N)

**有了平衡二叉树，为什么还需要红黑树？**

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
- 红黑树的查询效率虽然略逊与AVL，但红黑树通过牺牲严格的平衡，**换取插入/删除时少量的旋转操作**，**整体性能优于AVL**
- 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
- 红黑树的红黑规则，保证最坏的情况下，也能在O(log2N)时间内完成查找操作。

### **1.2.红黑树相比于BST和AVL树有什么优点？**

红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。

相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。

红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的

### 1.2 红黑规则

![image-20221009102244204](C:\Users\龚chang\AppData\Roaming\Typora\typora-user-images\image-20221009102244204.png)

- 从图示，可以发现红黑树的一些规律：
  - 节点不是红色就是黑色，根节点是黑色
  - 红黑树的叶子节点并非传统的叶子节点，红黑树的叶子节点是null节点（空节点）且为黑色
  - 同一路径，不存在连续的红色节点

**红黑规则**:

1. 节点不是黑色，就是红色（非黑即红）
2. 根节点为黑色
3. 叶节点为黑色（叶节点是指末梢的空节点 `Nil`或`Null`）
4. 一**个节点为红色，则其两个子节点必须是黑色的**（根到叶子的所有路径，不可能存在两个连续的红色节点）
5. **每个节点到叶子节点的所有路径，都包含相同数目的黑色节点**（相同的黑色高度）

### 1.3 红黑树的应用

Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构
JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树
Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。
多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。

## 2. 红黑树的左旋右旋

### 2.1 红黑树的定义

- 上一章节可知，红黑树要比[二叉搜索树](https://so.csdn.net/so/search?q=二叉搜索树&spm=1001.2101.3001.7020)多一个颜色属性
- 同时，为了方便确认插入位置，还可以多一个parent属性，用于表示当前节点的父节点
- 因此，红黑树节点的定义如下：

```java
public class RedBlackTree {
    // 当前红黑树的根节点，默认为null
    private RedBlackTreeNode root;
    
    class RedBlackTreeNode {
        public int val;
        public RedBlackTreeNode left;
        public RedBlackTreeNode right;
        // 记录节点颜色的color属性，暂定true表示红色
        public boolean color;
        // 为了方便迭代插入，包含一个父节点的引用
        public RedBlackTreeNode parent;

        // 一些构造函数，根据实际需求构建
        public RedBlackTreeNode() {
        }
	}
}


```

